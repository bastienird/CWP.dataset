# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand # nolint: line_length_linter.

#' Create Bar Plots from Measurement Data
#'
#' @description This function creates bar plots comparing measurement data for one or two datasets.
#' @param first A data frame representing the first dataset.
#' @param second An optional second data frame.
#' @param dimension A character string indicating the dimension for grouping.
#' @param topn An integer for the number of top categories to display.
#' @param titre_1 A character string for the title of the first dataset.
#' @param titre_2 A character string for the title of the second dataset.
#' @param fill_colors Optional vector of fill colors for the bars.
#' @param outline_colors Optional vector of outline colors for the bars.
#' @return A bar plot object.
#' @export
bar_plot_default <- function(first,
                             second = NULL,
                             dimension,
                             topn = 10,
                             titre_1 = "first",
                             titre_2= "second",
                             fill_colors = NULL,
                             outline_colors = NULL) {

  name1 = titre_1
  name2 = titre_2


  # Handle NA values and get dimension name
  first[is.na(first)] <- "NA"


  if (deparse(substitute(dimension)) == "X[[i]]") {
    r <- dimension
  } else {
    r <- deparse(substitute(dimension))
  }
  dimension <- gsub("\"", "", r)

  if (dimension == "source_authority") {
    topn = 6
  }
  first$dataset <- name1
  second$dataset <- name2
  dataset <- rbind(first, second)
  # Function to generate summary and plot
  generate_plot <- function(data, title, dimensioninside, topninside, dataset) {

    data_summary <- data %>%
      dplyr::group_by(dplyr::across(c(dimensioninside,   "measurement_unit", dataset))) %>% dplyr::summarise(measurement_value = sum(measurement_value, na.rm = TRUE)) %>% dplyr::group_by(measurement_unit, dataset) %>%
      dplyr::arrange(desc(measurement_value)) %>% dplyr::mutate(id = row_number()) %>%
      dplyr::mutate(class = as.factor(ifelse(id < topn, !!rlang::sym(dimensioninside), "Others"))) %>%       dplyr::group_by(class, measurement_unit, dataset) %>%
      dplyr::summarise(measurement_value = sum(measurement_value, na.rm = TRUE)) %>%
      group_by(measurement_unit, dataset) %>%
      dplyr::arrange(desc(ifelse(class == "Others", -Inf, measurement_value))) # Order data

    # Reorder class as a factor
    # data_summary$class <- factor(data_summary$class, levels = data_summary$class)

    # Create the bar plot
    plot <- ggplot(data = data_summary, aes(x = class, y = measurement_value, fill = class, color = class)) +
      geom_col() +
      labs(x = dimension, y = "Total Measurement") +
      scale_y_continuous(labels = function(x) prettyNum(x, big.mark = ",")) +
      theme(legend.position = "bottom",
            legend.title = element_blank(),
            legend.text = element_text(size = 7),
            legend.key.size = unit(.4, "cm"),
            axis.text.x = element_blank()) +
      ggtitle(title)+
      facet_grid(c("measurement_unit", "dataset"))


    if (!is.null(fill_colors) && !is.null(outline_colors)) {
      plot <- plot +
        scale_fill_manual(values = fill_colors) +
        scale_color_manual(values = outline_colors)
    }

    return(plot)
  }

  # Generate plot for initial data
  if(is.null(second)){
    bar_plot <- generate_plot(first, title = NULL, dimensioninside = dimension, topninside = topn)
  } else {

    # If final data is provided, generate plot for final data and return combined plot
    second[is.na(second)] <- "NA"
    bar_plot <- generate_plot(dataset,title =NULL, dimensioninside = dimension, topninside = topn)
    # bar_plot <- plot_grid(bar_plot, bar_plot_final, ncol = 2)
  }
  return(bar_plot)
}
